package com.mlblab.twitterSec.journal

import org.apache.spark.SparkConf
import org.apache.spark.SparkContext
import org.apache.spark.mllib.regression.LabeledPoint
import org.apache.spark.mllib.util.MLUtils
import org.apache.spark.rdd.RDD
import com.mlblab.twitterSec.utils.ClassifierUtils
import com.mlblab.twitterSec.utils.MislabeledLabeledPoint
import com.mlblab.twitterSec.DBUtils

object DatedMalware {
    val conf = new SparkConf().setAppName(this.getClass.getSimpleName).setMaster("local[10]").setExecutorEnv("spark.executor.memory", "40g").set("spark.driver.memory", "24g")
    val sc = new SparkContext(conf)
    val output = new StringBuilder()

  def main(args: Array[String]) : Unit = {
    val useCache = true
    var androzoo:RDD[LabeledPoint] = null
    var playdrone:RDD[LabeledPoint] = null
    
    if(useCache) {
      androzoo = sc.objectFile[LabeledPoint]("datedMalware.androzoo.cache")
      playdrone = sc.objectFile[LabeledPoint]("datedMalware.playdrone.cache")      
    } else {
      androzoo = DBUtils.readInAndroZooFeatureResults("/Users/jdeloach/Documents/ML Data/2016/500kAndroZooTables.txt", sc).repartition(100)
      androzoo.saveAsObjectFile("datedMalware.androzoo.cache")
      playdrone = DBUtils.load2016LabelsSimple(sc).map(_._2).repartition(100).cache
      playdrone.saveAsObjectFile("datedMalware.playdrone.cache")
    }
    
    output.append(s"androzoo pos: ${androzoo.filter(_.label == 1).count}, neg: ${androzoo.filter(_.label == 0).count}, total: ${androzoo.count}\n")
    output.append(s"playdrone pos: ${playdrone.filter(_.label == 1).count}, neg: ${playdrone.filter(_.label == 0).count}, total: ${playdrone.count}\n")
    
    supervisedLearningTest(playdrone, androzoo)
    semiSupervisedLearningTest(playdrone, androzoo)
    
    println(output.toString)
  }

  /**
   * Training: Dated e.g. PlayDrone App Sets (Positive and Negative)
   * Testing: Modern e.g. AndroZoo App Sets (Positive and Negative)
   */
  def supervisedLearningTest(playdrone: RDD[LabeledPoint], androzoo: RDD[LabeledPoint]) = {
    val playdroneFolds = MLUtils.kFold(playdrone, 5, 44) // RDD[(train,test)]
    val androzooFolds = MLUtils.kFold(androzoo, 5, 44)
    val folds = playdroneFolds.zip(androzooFolds).map { case (playDrone,androZoo) => (ClassifierUtils.undersample(playDrone._1),androZoo._2) } // playDrone train, androZoo test
    
    val nbPRC = ClassifierUtils.naiveBayes(folds)
    val svmPRC = ClassifierUtils.svm(folds)
    val lrPRC = ClassifierUtils.logisticRegression(folds)
    
    output.append(s"datedMalware.supervisedLearning naiveBayes auPRC: $nbPRC\n")
    output.append(s"datedMalware.supervisedLearning svm auPRC: $svmPRC\n")
    output.append(s"datedMalware.supervisedLearning logisticRegression auPRC: $lrPRC\n")
  }
  
  /**
   * Training: Dated Positives as L_p, and Modern (all) as unlabeled.
   * Testing: Modern
   */
  def semiSupervisedLearningTest(playdrone: RDD[LabeledPoint], androzoo: RDD[LabeledPoint]) = {
    val datedPositives = playdrone.filter { x => x.label == 1 }
    val datedPositivesTrainFolds = MLUtils.kFold(datedPositives, 5, 44).map{ case (train,test) => (train,sc.emptyRDD[LabeledPoint]) }
    val modernUnlabeledFolds = MLUtils.kFold(androzoo, 5, 44).map{ case (train,test) => (labeledToUnlabeled(train), test) }
    val folds = modernUnlabeledFolds.zip(datedPositivesTrainFolds).map{ case (set1,set2) => (ClassifierUtils.undersample(set1._1 ++ set2._1), set1._2 ++ set2._2) }
    
    val pTilde = androzoo.filter(_.label == 1).count / androzoo.count.toDouble
    val lrlrPRC = ClassifierUtils.lrlr(folds,pTilde,1)

    output.append(s"datedMalware.semiSupervisedLearning for a datedPositivesTrainFolds, train: ${datedPositivesTrainFolds(0)._1.count}, test: ${datedPositivesTrainFolds(0)._2.count}\n")
    output.append(s"datedMalware.semiSupervisedLearning for a modernUnlabeledFolds, train: ${modernUnlabeledFolds(0)._1.count}, test: ${modernUnlabeledFolds(0)._2.count}\n")

    output.append(s"datedMalware.semiSupervisedLearning for a fold, train: ${folds(0)._1.count}, test: ${folds(0)._2.count}\n")
    output.append(s"datedMalware.semiSupervisedLearning for a train fold, pos: ${folds(0)._1.filter(_.label == 1).count}, neg: ${folds(0)._1.filter(_.label == 0).count}\n")
    output.append(s"datedMalware.semiSupervisedLearning for a test fold, pos: ${folds(0)._2.filter(_.label == 1).count}, neg: ${folds(0)._2.filter(_.label == 0).count}\n")
    output.append(s"datedMalware.semiSupervisedLearning lrLR auPRC: $lrlrPRC, where pTilde: $pTilde\n")
  }
  
  def labeledToUnlabeled(points: RDD[LabeledPoint]) = points.map { x => new LabeledPoint(0, x.features) }
}